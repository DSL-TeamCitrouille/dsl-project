<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DamDamClassic - With Bot</title>
  <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 { 
            margin-bottom: 10px; 
            color: #333; 
            font-size: 28px;
        }

        .status {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #666;
            min-height: 24px;
        }

        .board {
            display: inline-grid;
            grid-template-columns: repeat(8, 50px);
            gap: 0;
            border: 3px solid #333;
            margin-bottom: 20px;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .square {
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s ease;
            user-select: none;
        }

        .square:hover { 
            filter: brightness(0.95);
        }

        .square.selected {
            box-shadow: inset 0 0 10px rgba(255, 200, 0, 0.8);
            background-color: rgba(255, 200, 0, 0.2) !important;
        }

        .square.legalmoves {
            box-shadow: inset 0 0 10px rgba(218, 76, 253, 0.8);
            background-color: rgba(255, 200, 0, 0.2) !important;
        }

        .piece {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        .square:hover .piece {
            transform: scale(1.1);
        }

        .piece.white { 
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            color: #333; 
            border: 2px solid #333; 
        }
        .piece.black { 
            background: linear-gradient(135deg, #333333 0%, #1a1a1a 100%);
        }
        .piece.red { 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
        }
        .piece.blue { 
            background: linear-gradient(135deg, #4ecdc4 0%, #44a5c2 100%);
        }
        .piece.green { 
            background: linear-gradient(135deg, #95de64 0%, #69db7c 100%);
            color: #333;
        }
        .piece.yellow { 
            background: linear-gradient(135deg, #ffd93d 0%, #ffec99 100%);
            color: #333;
        }

        .piece.queen::after {
            content: 'üëë';
            position: absolute;
            font-size: 16px;
            top: -2px;
            right: 0px;
        }

        .piece.queen {
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 8px rgba(255, 215, 0, 0.6);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            background: #2196F3;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        button:hover { 
            background: #1976D2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .reset-btn { 
            background: #4CAF50;
        }
        .reset-btn:hover { 
            background: #45a049;
        }
        
        .forfait-btn {
            background: #FF5722;
        }
        .forfait-btn:hover {
            background: #E64A19;
        }

        .bot-btn {
            background: #9C27B0;
        }
        .bot-btn:hover {
            background: #7B1FA2;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 22px;
        }

        .modal-content p {
            margin-bottom: 25px;
            color: #666;
            font-size: 16px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-buttons button {
            padding: 10px 25px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .confirm-btn {
            background: #FF5722;
            color: white;
        }

        .confirm-btn:hover {
            background: #E64A19;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .cancel-btn {
            background: #757575;
            color: white;
        }

        .cancel-btn:hover {
            background: #616161;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 8px 16px;
            font-size: 13px;
            background: #eee;
            color: #333;
        }

        .mode-btn.active {
            background: #2196F3;
            color: white;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            .board {
                margin-bottom: 15px;
            }
            .controls {
                gap: 8px;
            }
            button {
                padding: 8px 16px;
                font-size: 12px;
            }
        }

        .dice.rolling {
            animation: diceRoll 0.6s ease-in-out;
        }

        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg) scale(1.1); }
        }

        .throw-button:hover {
            background: #F57C00 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .throw-button:active {
            transform: translateY(0);
        }

        .throw-button:disabled {
            background: #ccc !important;
            cursor: not-allowed;
            transform: none;
        }

        .toggle-hints-btn {
            display: center;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            }

        .toggle-hints-btn:hover {
            background-color: #1976D2;
        }

        .toggle-hints-btn.active {
            background-color: #2196F3;
            color: white;
        }

        .toggle-hints-btn {
            background-color: #eee;
            color: white;
        }
    </style>
</head>
<body>
  <div class="container">
        <h1>üéÆ DamDamClassic</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="pvp">üë• Player vs Player</button>
            <button class="mode-btn" data-mode="pvb">ü§ñ Player vs Bot</button>
            <button class="mode-btn" data-mode="bvb">ü§ñü§ñ Bot vs Bot</button>
        </div>
        <button class="toggle-hints-btn">üí° Aide</button>
        <div class="status">Loading...</div>
        <div style="display: flex; justify-content: center; align-items: flex-start; gap: 20px;">
            <div class="board"><div class="square" data-row="0" data-col="0" style="background-color: beige;"></div><div class="square" data-row="0" data-col="1" style="background-color: brown;"></div><div class="square" data-row="0" data-col="2" style="background-color: beige;"></div><div class="square" data-row="0" data-col="3" style="background-color: brown;"></div><div class="square" data-row="0" data-col="4" style="background-color: beige;"></div><div class="square" data-row="0" data-col="5" style="background-color: brown;"></div><div class="square" data-row="0" data-col="6" style="background-color: beige;"></div><div class="square" data-row="0" data-col="7" style="background-color: brown;"></div><div class="square" data-row="1" data-col="0" style="background-color: brown;"></div><div class="square" data-row="1" data-col="1" style="background-color: beige;"></div><div class="square" data-row="1" data-col="2" style="background-color: brown;"></div><div class="square" data-row="1" data-col="3" style="background-color: beige;"></div><div class="square" data-row="1" data-col="4" style="background-color: brown;"></div><div class="square" data-row="1" data-col="5" style="background-color: beige;"></div><div class="square" data-row="1" data-col="6" style="background-color: brown;"></div><div class="square" data-row="1" data-col="7" style="background-color: beige;"></div><div class="square" data-row="2" data-col="0" style="background-color: beige;"></div><div class="square" data-row="2" data-col="1" style="background-color: brown;"></div><div class="square" data-row="2" data-col="2" style="background-color: beige;"></div><div class="square" data-row="2" data-col="3" style="background-color: brown;"></div><div class="square" data-row="2" data-col="4" style="background-color: beige;"></div><div class="square" data-row="2" data-col="5" style="background-color: brown;"></div><div class="square" data-row="2" data-col="6" style="background-color: beige;"></div><div class="square" data-row="2" data-col="7" style="background-color: brown;"></div><div class="square" data-row="3" data-col="0" style="background-color: brown;"></div><div class="square" data-row="3" data-col="1" style="background-color: beige;"></div><div class="square" data-row="3" data-col="2" style="background-color: brown;"></div><div class="square" data-row="3" data-col="3" style="background-color: beige;"></div><div class="square" data-row="3" data-col="4" style="background-color: brown;"></div><div class="square" data-row="3" data-col="5" style="background-color: beige;"></div><div class="square" data-row="3" data-col="6" style="background-color: brown;"></div><div class="square" data-row="3" data-col="7" style="background-color: beige;"></div><div class="square" data-row="4" data-col="0" style="background-color: beige;"></div><div class="square" data-row="4" data-col="1" style="background-color: brown;"></div><div class="square" data-row="4" data-col="2" style="background-color: beige;"></div><div class="square" data-row="4" data-col="3" style="background-color: brown;"></div><div class="square" data-row="4" data-col="4" style="background-color: beige;"></div><div class="square" data-row="4" data-col="5" style="background-color: brown;"></div><div class="square" data-row="4" data-col="6" style="background-color: beige;"></div><div class="square" data-row="4" data-col="7" style="background-color: brown;"></div><div class="square" data-row="5" data-col="0" style="background-color: brown;"></div><div class="square" data-row="5" data-col="1" style="background-color: beige;"></div><div class="square" data-row="5" data-col="2" style="background-color: brown;"></div><div class="square" data-row="5" data-col="3" style="background-color: beige;"></div><div class="square" data-row="5" data-col="4" style="background-color: brown;"></div><div class="square" data-row="5" data-col="5" style="background-color: beige;"></div><div class="square" data-row="5" data-col="6" style="background-color: brown;"></div><div class="square" data-row="5" data-col="7" style="background-color: beige;"></div><div class="square" data-row="6" data-col="0" style="background-color: beige;"></div><div class="square" data-row="6" data-col="1" style="background-color: brown;"></div><div class="square" data-row="6" data-col="2" style="background-color: beige;"></div><div class="square" data-row="6" data-col="3" style="background-color: brown;"></div><div class="square" data-row="6" data-col="4" style="background-color: beige;"></div><div class="square" data-row="6" data-col="5" style="background-color: brown;"></div><div class="square" data-row="6" data-col="6" style="background-color: beige;"></div><div class="square" data-row="6" data-col="7" style="background-color: brown;"></div><div class="square" data-row="7" data-col="0" style="background-color: brown;"></div><div class="square" data-row="7" data-col="1" style="background-color: beige;"></div><div class="square" data-row="7" data-col="2" style="background-color: brown;"></div><div class="square" data-row="7" data-col="3" style="background-color: beige;"></div><div class="square" data-row="7" data-col="4" style="background-color: brown;"></div><div class="square" data-row="7" data-col="5" style="background-color: beige;"></div><div class="square" data-row="7" data-col="6" style="background-color: brown;"></div><div class="square" data-row="7" data-col="7" style="background-color: beige;"></div></div>
            <div class="dice-container"></div>
        </div>
        
        <div class="controls">
            <button class="reset-btn">‚Üª Reset</button>
            <button class="bot-btn" style="display:none;">ü§ñ Bot Move</button>
            <button class="forfait-btn">üè≥Ô∏è Forfait</button>
        </div>

        <!-- Forfait Confirmation Modal -->
        <div class="modal" id="forfaitModal">
            <div class="modal-content">
                <h2>Forfait Confirmation</h2>
                <p>Are you sure you want to forfait? You will lose the game.</p>
                <div class="modal-buttons">
                    <button class="confirm-btn" id="confirmForfait">Yes, Forfait</button>
                    <button class="cancel-btn" id="cancelForfait">No, Continue</button>
                </div>
            </div>
        </div>
    </div>

  <script>
    window.__GAME_CONFIG = {"boardSize":8,"direction":"diagonal","firstPlayer":0,"mandatoryCapture":true,"pieces":[{"name":"white","color":"white","quantity":12},{"name":"black","color":"black","quantity":12}],"dice":null};
  </script>
  <script>
"use strict";
(() => {
  // packages/cli/out/scripts/game.js
  var Game = class {
    constructor(boardSize, direction, pieces_config, firstPlayer = 0, isCaptureManutory = false, diceConfig = null) {
      this.pieces = /* @__PURE__ */ new Map();
      this.firstPlayer = 0;
      this.currentPlayer = 0;
      this.gameOver = false;
      this.winner = null;
      this.nextId = 0;
      this.diceConfig = null;
      this.diceResult = null;
      this.boardSize = boardSize;
      this.pieces = /* @__PURE__ */ new Map();
      this.firstPlayer = firstPlayer;
      this.currentPlayer = firstPlayer;
      this.gameOver = false;
      this.winner = null;
      this.direction = direction;
      this.pieces_config = pieces_config;
      this.isCaptureManutory = isCaptureManutory;
      this.nextId = 0;
      this.diceConfig = diceConfig;
      this.diceResult = null;
      this.movesRemaining = 0;
      this.mustRollDice = diceConfig !== null;
      this.initBoard();
    }
    initBoard() {
      for (let playerId = 0; playerId < this.pieces_config.length; playerId++) {
        const cfg2 = this.pieces_config[playerId];
        const positions = this.getStartPositions(playerId, cfg2.quantity);
        for (const pos of positions) {
          const piece = {
            id: `p${this.nextId++}`,
            name: cfg2.name,
            player: playerId,
            color: cfg2.color,
            row: pos.row,
            col: pos.col,
            isQueen: false
          };
          this.pieces.set(piece.id, piece);
        }
      }
    }
    getStartPositions(playerId, quantity) {
      const pos = [];
      const size = this.boardSize;
      if (this.pieces_config.length === 2) {
        const isSecond = playerId === 1;
        if (this.direction === "diagonal") {
          let placed = 0;
          if (isSecond) {
            for (let r = size - 1; r >= 0 && placed < quantity; r--) {
              for (let c = size - 1; c >= 0 && placed < quantity; c--) {
                if ((r + c) % 2 === 1) {
                  pos.push({ row: r, col: c });
                  placed++;
                }
              }
            }
          } else {
            for (let r = 0; r < size && placed < quantity; r++) {
              for (let c = 0; c < size && placed < quantity; c++) {
                if ((r + c) % 2 === 1) {
                  pos.push({ row: r, col: c });
                  placed++;
                }
              }
            }
          }
        } else {
          let placed = 0;
          if (isSecond) {
            for (let r = size - 2; r >= 0 && placed < quantity; r--) {
              for (let c = 0; c < size && placed < quantity; c++) {
                pos.push({ row: r, col: c });
                placed++;
              }
            }
          } else {
            for (let r = 1; r < size && placed < quantity; r++) {
              for (let c = 0; c < size && placed < quantity; c++) {
                pos.push({ row: r, col: c });
                placed++;
              }
            }
          }
        }
      }
      if (this.pieces_config.length === 1) {
        let placed = 0;
        for (let r = 0; r < size && placed < quantity; r++) {
          for (let c = 0; c < size && placed < quantity; c++) {
            pos.push({ row: r, col: c });
            placed++;
          }
        }
        return pos;
      }
      return pos;
    }
    getLegalMoves() {
      if (this.pieces_config.length === 1) {
        const moves2 = [];
        this.pieces.forEach((piece) => {
          moves2.push(...this.getMovesForPiece(piece, false));
        });
        return moves2;
      }
      const moves = [];
      if (this.isCaptureManutory) {
        let hasAnyCaptures = false;
        this.pieces.forEach((piece) => {
          if (piece.player === this.currentPlayer) {
            const jumpMoves = this.getJumpMoves(piece, /* @__PURE__ */ new Set());
            if (jumpMoves.length > 0) {
              hasAnyCaptures = true;
            }
          }
        });
        this.pieces.forEach((piece) => {
          if (piece.player === this.currentPlayer) {
            if (hasAnyCaptures) {
              const jumpMoves = this.getJumpMoves(piece, /* @__PURE__ */ new Set());
              moves.push(...jumpMoves);
            } else {
              moves.push(...this.getMovesForPiece(piece, true));
            }
          }
        });
      } else {
        this.pieces.forEach((piece) => {
          if (piece.player === this.currentPlayer) {
            moves.push(...this.getMovesForPiece(piece, false));
          }
        });
      }
      return moves;
    }
    getMovesForPiece(piece, skipJumps = false) {
      const moves = [];
      const jumpMoves = this.getJumpMoves(piece, /* @__PURE__ */ new Set());
      if (!skipJumps && jumpMoves.length > 0) {
        moves.push(...jumpMoves);
      }
      let dirs = this.direction === "diagonal" ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] : this.direction === "orthogonal" ? [[-1, 0], [1, 0], [0, -1], [0, 1]] : [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
      if (this.direction === "diagonal" && this.pieces_config.length !== 1) {
        if (!piece.isQueen) {
          if (piece.player === 0) {
            dirs = dirs.filter(([dr]) => dr > 0);
          } else {
            dirs = dirs.filter(([dr]) => dr < 0);
          }
        }
      } else if (this.direction === "orthogonal" && this.pieces_config.length !== 1) {
        if (!piece.isQueen) {
          if (piece.player === 0) {
            dirs = dirs.filter(([dr, dc]) => dr > 0 || dc !== 0);
          } else {
            dirs = dirs.filter(([dr, dc]) => dr < 0 || dc !== 0);
          }
        }
      }
      if (this.pieces_config.length === 1) {
        dirs = [];
      }
      for (const [dr, dc] of dirs) {
        const maxDistance = piece.isQueen ? this.boardSize : 1;
        for (let distance = 1; distance <= maxDistance; distance++) {
          const newRow = piece.row + dr * distance;
          const newCol = piece.col + dc * distance;
          if (newRow < 0 || newRow >= this.boardSize || newCol < 0 || newCol >= this.boardSize) {
            break;
          }
          const targetPiece = this.getPieceAt(newRow, newCol);
          if (!targetPiece) {
            moves.push({
              from: { row: piece.row, col: piece.col },
              to: { row: newRow, col: newCol }
            });
          } else {
            break;
          }
        }
      }
      return moves;
    }
    getJumpMoves(piece, capturedIds, originalFrom = null) {
      if (originalFrom === null) {
        originalFrom = { row: piece.row, col: piece.col };
      }
      const moves = [];
      let dirs = this.direction === "diagonal" ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] : this.direction === "orthogonal" ? [[-1, 0], [1, 0], [0, -1], [0, 1]] : [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
      if (this.direction === "diagonal") {
        if (!piece.isQueen) {
          if (piece.player === 0) {
            dirs = dirs.filter(([dr]) => dr > 0);
          } else {
            dirs = dirs.filter(([dr]) => dr < 0);
          }
        }
      } else if (this.direction === "orthogonal") {
        if (!piece.isQueen && this.pieces_config.length !== 1) {
          if (piece.player === 0) {
            dirs = dirs.filter(([dr, dc]) => dr > 0 || dc !== 0);
          } else {
            dirs = dirs.filter(([dr, dc]) => dr < 0 || dc !== 0);
          }
        }
      }
      for (const [dr, dc] of dirs) {
        const maxDistance = piece.isQueen ? this.boardSize : 1;
        let foundEnemy = false;
        let enemyPos = null;
        for (let distance = 1; distance <= maxDistance; distance++) {
          const targetRow = piece.row + dr * distance;
          const targetCol = piece.col + dc * distance;
          const landRow = piece.row + dr * (distance + 1);
          const landCol = piece.col + dc * (distance + 1);
          if (landRow < 0 || landRow >= this.boardSize || landCol < 0 || landCol >= this.boardSize) {
            break;
          }
          const targetPiece = this.getPieceAt(targetRow, targetCol);
          if (targetPiece && (targetPiece.player !== piece.player || this.pieces_config.length === 1) && !capturedIds.has(targetPiece.id)) {
            if (!foundEnemy) {
              foundEnemy = true;
              enemyPos = { row: targetRow, col: targetCol };
              const landingPiece = this.getPieceAt(landRow, landCol);
              if (!landingPiece) {
                const newCapturedIds = new Set(capturedIds);
                newCapturedIds.add(targetPiece.id);
                const jumpMove = {
                  from: { row: originalFrom.row, col: originalFrom.col },
                  to: { row: landRow, col: landCol },
                  capturedIds: Array.from(newCapturedIds)
                };
                moves.push(jumpMove);
                const tempPiece = { ...piece, row: landRow, col: landCol };
                const chainMoves = this.getJumpMoves(tempPiece, newCapturedIds, originalFrom);
                if (chainMoves.length > 0) {
                  moves.push(...chainMoves);
                }
              }
            } else {
              if (enemyPos) {
                const distBetweenEnemies = distance - Math.abs(enemyPos.row - piece.row) - 1;
                if (distBetweenEnemies > 0) {
                  const landingPiece = this.getPieceAt(landRow, landCol);
                  if (!landingPiece) {
                    const newCapturedIds = new Set(capturedIds);
                    newCapturedIds.add(targetPiece.id);
                    const jumpMove = {
                      from: { row: originalFrom.row, col: originalFrom.col },
                      to: { row: landRow, col: landCol },
                      capturedIds: Array.from(newCapturedIds)
                    };
                    moves.push(jumpMove);
                    const tempPiece = { ...piece, row: landRow, col: landCol };
                    const chainMoves = this.getJumpMoves(tempPiece, newCapturedIds, originalFrom);
                    if (chainMoves.length > 0) {
                      moves.push(...chainMoves);
                    }
                  }
                }
              }
            }
          } else if (targetPiece && targetPiece.player === piece.player) {
            break;
          }
        }
      }
      return moves;
    }
    getPieceAt(row, col) {
      for (const piece of this.pieces.values()) {
        if (piece.row === row && piece.col === col)
          return piece;
      }
      return null;
    }
    executeMove(move) {
      if (this.diceConfig && this.mustRollDice) {
        console.log("Must roll dice before moving!");
        return false;
      }
      if (this.diceConfig && this.movesRemaining <= 0) {
        console.log("No moves remaining! Roll the dice again.");
        return false;
      }
      const legalMoves = this.getLegalMoves();
      const isLegal = legalMoves.some((m) => m.from.row === move.from.row && m.from.col === move.from.col && m.to.row === move.to.row && m.to.col === move.to.col);
      if (!isLegal) {
        return false;
      }
      const piece = this.getPieceAt(move.from.row, move.from.col);
      if (!piece) {
        return false;
      }
      if (move.capturedIds && move.capturedIds.length > 0) {
        for (const capturedId of move.capturedIds) {
          this.pieces.delete(capturedId);
        }
      }
      piece.row = move.to.row;
      piece.col = move.to.col;
      if (this.pieces_config.length !== 1) {
        const isPromotionRow = piece.player === 0 && piece.row === this.boardSize - 1 || piece.player === 1 && piece.row === 0;
        if (isPromotionRow && !piece.isQueen) {
          piece.isQueen = true;
        }
      }
      if (this.diceConfig) {
        this.movesRemaining--;
        if (this.movesRemaining <= 0) {
          this.checkWin();
          if (!this.gameOver) {
            if (this.pieces_config.length === 1) {
              this.currentPlayer = 0;
            } else {
              this.currentPlayer = 1 - this.currentPlayer;
            }
            this.mustRollDice = true;
            this.diceResult = null;
          }
        }
      } else {
        this.checkWin();
        if (!this.gameOver) {
          if (this.pieces_config.length === 1) {
            this.currentPlayer = 0;
          } else {
            this.currentPlayer = 1 - this.currentPlayer;
          }
        }
      }
      return true;
    }
    rollDice() {
      if (!this.diceConfig || typeof this.diceConfig.faces !== "number") {
        console.error("Invalid dice configuration");
        return null;
      }
      if (!this.mustRollDice) {
        console.log("Already rolled dice for this turn!");
        return null;
      }
      const result = Math.floor(Math.random() * this.diceConfig.faces) + 1;
      this.diceResult = result;
      this.movesRemaining = result;
      this.mustRollDice = false;
      console.log(`Dice rolled: ${result}. You have ${result} moves.`);
      return result;
    }
    checkWin() {
      if (this.pieces_config.length === 1) {
        const pieces = Array.from(this.pieces.values()).filter((p) => p.player === 0);
        if (pieces.length === 1) {
          this.gameOver = true;
          this.winner = 0;
          return;
        }
        if (this.getLegalMoves().length === 0 && pieces.length !== 1) {
          this.gameOver = true;
          this.winner = null;
          return;
        }
      } else {
        const p0Pieces = Array.from(this.pieces.values()).filter((p) => p.player === 0);
        const p1Pieces = Array.from(this.pieces.values()).filter((p) => p.player === 1);
        if (p1Pieces.length === 0) {
          this.gameOver = true;
          this.winner = 0;
        } else if (p0Pieces.length === 0) {
          this.gameOver = true;
          this.winner = 1;
        }
      }
    }
    forceEndGame() {
      const p0Pieces = Array.from(this.pieces.values()).filter((p) => p.player === 0);
      const p1Pieces = Array.from(this.pieces.values()).filter((p) => p.player === 1);
      if (p0Pieces.length > p1Pieces.length) {
        this.winner = 0;
      } else if (p1Pieces.length > p0Pieces.length) {
        this.winner = 1;
      } else {
        this.winner = 1 - this.currentPlayer;
      }
      this.gameOver = true;
    }
    reset() {
      this.pieces.clear();
      this.currentPlayer = this.firstPlayer;
      this.gameOver = false;
      this.winner = null;
      this.nextId = 0;
      this.initBoard();
      this.diceResult = null;
      this.movesRemaining = 0;
      this.mustRollDice = this.diceConfig !== null;
    }
  };

  // packages/cli/out/scripts/randomBot.js
  var Bot = class {
    constructor(game, playerId) {
      this.game = game;
      this.playerId = playerId;
    }
    /**
     * Makes a random legal move for the bot's player
     * @returns The move that was made, or null if no legal moves available
     */
    makeMove() {
      if (this.game.currentPlayer !== this.playerId || this.game.gameOver) {
        return null;
      }
      const legalMoves = this.game.getLegalMoves();
      if (legalMoves.length === 0) {
        return null;
      }
      const randomIndex = Math.floor(Math.random() * legalMoves.length);
      const selectedMove = legalMoves[randomIndex];
      const success = this.game.executeMove(selectedMove);
      if (success) {
        return selectedMove;
      }
      return null;
    }
    /**
     * Makes a move after a delay (useful for UI visualization)
     * @param delayMs Delay in milliseconds before making the move
     * @returns Promise that resolves with the move that was made
     */
    async makeMoveWithDelay(delayMs = 500) {
      if (this.game.diceConfig && this.game.mustRollDice) {
        const result = this.game.rollDice();
        if (!result)
          return null;
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
      if (this.game.diceConfig && this.game.movesRemaining <= 0) {
        return null;
      }
      await new Promise((resolve) => setTimeout(resolve, delayMs));
      return this.makeMove();
    }
  };

  // packages/cli/out/scripts/ui.js
  var UI = class {
    constructor(game) {
      this.selected = null;
      this.mode = "pvp";
      this.isProcessing = false;
      this.stopBotLoop = false;
      this.showLegalMoves = true;
      this.game = game;
      this.bot1 = new Bot(game, 1);
      this.bot0 = new Bot(game, 0);
      this.setupEvents();
      this.render();
    }
    setupEvents() {
      const squares = document.querySelectorAll(".square");
      squares.forEach((square) => {
        square.addEventListener("click", (e) => this.handleClick(e));
      });
      const resetBtn = document.querySelector(".reset-btn");
      if (resetBtn) {
        resetBtn.addEventListener("click", () => {
          this.game.reset();
          this.selected = null;
          this.render();
          this.checkBotTurn();
        });
      }
      const botBtn = document.querySelector(".bot-btn");
      if (botBtn) {
        botBtn.addEventListener("click", async () => {
          await this.triggerBotMove();
        });
      }
      const toggleHintsBtn = document.querySelector(".toggle-hints-btn");
      if (toggleHintsBtn) {
        toggleHintsBtn.classList.add("active");
        toggleHintsBtn.addEventListener("click", () => {
          this.showLegalMoves = !this.showLegalMoves;
          toggleHintsBtn.classList.toggle("active");
          toggleHintsBtn.textContent = this.showLegalMoves ? "\u{1F4A1} Aide" : "\u{1F4A1} Aide (d\xE9sactiv\xE9e)";
          this.render();
        });
      }
      const forfaitBtn = document.querySelector(".forfait-btn");
      const forfaitModal = document.getElementById("forfaitModal");
      const confirmForfait = document.getElementById("confirmForfait");
      const cancelForfait = document.getElementById("cancelForfait");
      if (forfaitBtn) {
        forfaitBtn.addEventListener("click", () => {
          if (!this.game.gameOver) {
            forfaitModal?.classList.add("active");
          }
        });
      }
      if (confirmForfait) {
        confirmForfait.addEventListener("click", () => {
          this.stopBotLoop = true;
          this.game.forceEndGame();
          this.selected = null;
          forfaitModal?.classList.remove("active");
          this.render();
        });
      }
      if (cancelForfait) {
        cancelForfait.addEventListener("click", () => {
          forfaitModal?.classList.remove("active");
        });
      }
      const modeBtns = document.querySelectorAll(".mode-btn");
      modeBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const newMode = btn.dataset.mode;
          this.setMode(newMode);
        });
      });
    }
    setMode(newMode) {
      this.stopBotLoop = true;
      this.mode = newMode;
      this.game.reset();
      this.selected = null;
      const modeBtns = document.querySelectorAll(".mode-btn");
      modeBtns.forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.mode === newMode);
      });
      const botBtn = document.querySelector(".bot-btn");
      if (botBtn) {
        botBtn.style.display = newMode === "pvb" ? "inline-block" : "none";
      }
      this.render();
      setTimeout(() => {
        this.stopBotLoop = false;
        this.checkBotTurn();
      }, 100);
    }
    async handleClick(e) {
      if (this.isProcessing || this.game.gameOver)
        return;
      if (this.mode === "bvb")
        return;
      if (this.mode === "pvb" && this.game.currentPlayer === 1)
        return;
      if (this.game.diceConfig && this.game.mustRollDice) {
        this.updateStatus("\u26A0\uFE0F You must roll the dice first!");
        return;
      }
      if (this.game.diceConfig && this.game.movesRemaining <= 0) {
        this.updateStatus("\u26A0\uFE0F No moves remaining! Roll the dice again.");
        return;
      }
      const target = e.target;
      const square = target?.closest?.(".square");
      if (!square)
        return;
      const rowStr = square.getAttribute("data-row");
      const colStr = square.getAttribute("data-col");
      if (!rowStr || !colStr)
        return;
      const row = parseInt(rowStr, 10);
      const col = parseInt(colStr, 10);
      const clickedPiece = this.getPieceAt(row, col);
      if (!this.selected) {
        if (clickedPiece && clickedPiece.player === this.game.currentPlayer) {
          if (this.game.isCaptureManutory) {
            const allLegalMoves = this.game.getLegalMoves();
            const hasCaptureMoves = allLegalMoves.some((m) => m.capturedIds && m.capturedIds.length > 0);
            if (hasCaptureMoves) {
              const pieceCanCapture = allLegalMoves.some((m) => m.from.row === clickedPiece.row && m.from.col === clickedPiece.col && m.capturedIds && m.capturedIds.length > 0);
              if (!pieceCanCapture) {
                this.updateStatus("\u26A0\uFE0F Mandatory capture! You must capture with another piece.");
                return;
              }
            }
          }
          this.selected = clickedPiece;
          this.render();
        }
      } else {
        if (clickedPiece && clickedPiece.player === this.game.currentPlayer) {
          this.selected = clickedPiece;
          this.render();
          return;
        }
        const move = {
          from: { row: this.selected.row, col: this.selected.col },
          to: { row, col }
        };
        const legalMoves = this.game.getLegalMoves();
        const matchingMove = legalMoves.find((m) => m.from.row === move.from.row && m.from.col === move.from.col && m.to.row === move.to.row && m.to.col === move.to.col);
        const moveToExecute = matchingMove || move;
        if (this.game.executeMove(moveToExecute)) {
          this.selected = null;
          this.render();
          await this.checkBotTurn();
        }
      }
    }
    updateStatus(message) {
      const status = document.querySelector(".status");
      if (status) {
        status.textContent = message;
        setTimeout(() => {
          this.render();
        }, 2e3);
      }
    }
    async triggerBotMove() {
      if (this.isProcessing || this.game.gameOver)
        return;
      this.isProcessing = true;
      this.render();
      if (this.mode === "pvb" && this.game.currentPlayer === 1) {
        await this.bot1.makeMoveWithDelay(500);
      }
      this.isProcessing = false;
      this.render();
    }
    async checkBotTurn() {
      if (this.game.gameOver || this.isProcessing)
        return;
      if (this.mode === "bvb") {
        this.isProcessing = true;
        this.stopBotLoop = false;
        while (!this.game.gameOver && !this.stopBotLoop && this.mode === "bvb") {
          this.render();
          await new Promise((resolve) => setTimeout(resolve, 800));
          if (this.stopBotLoop || this.mode !== "bvb")
            break;
          if (this.game.currentPlayer === 0) {
            await this.bot0.makeMoveWithDelay(100);
          } else {
            await this.bot1.makeMoveWithDelay(100);
          }
          if (this.game.gameOver || this.stopBotLoop || this.mode !== "bvb")
            break;
        }
        this.isProcessing = false;
        this.render();
      } else if (this.mode === "pvb" && this.game.currentPlayer === 1) {
        this.isProcessing = true;
        this.render();
        await this.bot1.makeMoveWithDelay(500);
        this.isProcessing = false;
        this.render();
      }
    }
    getPieceAt(row, col) {
      for (const piece of this.game.pieces.values()) {
        if (piece.row === row && piece.col === col)
          return piece;
      }
      return null;
    }
    render() {
      let legalDestinations = [];
      if (this.selected && this.showLegalMoves) {
        const allLegalMoves = this.game.getLegalMoves();
        legalDestinations = allLegalMoves.filter((m) => m.from.row === this.selected.row && m.from.col === this.selected.col).map((m) => ({ row: m.to.row, col: m.to.col }));
      }
      const squares = document.querySelectorAll(".square");
      squares.forEach((sq) => {
        const square = sq;
        const rowStr = square.getAttribute("data-row");
        const colStr = square.getAttribute("data-col");
        if (!rowStr || !colStr)
          return;
        const row = parseInt(rowStr, 10);
        const col = parseInt(colStr, 10);
        square.innerHTML = "";
        square.classList.remove("selected", "legalmoves");
        const piece = this.getPieceAt(row, col);
        if (piece) {
          const el = document.createElement("div");
          el.className = `piece ${piece.color}`;
          if (piece.isQueen) {
            el.classList.add("queen");
          }
          el.title = piece.isQueen ? piece.name + " (Queen)" : piece.name;
          square.appendChild(el);
        }
        if (this.selected && this.selected.row === row && this.selected.col === col) {
          square.classList.add("selected");
        }
        if (this.showLegalMoves && legalDestinations.some((dest) => dest.row === row && dest.col === col)) {
          square.classList.add("legalmoves");
        }
      });
      const status = document.querySelector(".status");
      const botBtn = document.querySelector(".bot-btn");
      const diceResult = document.querySelector(".dice-result");
      const throwButton = document.querySelector(".throw-button");
      if (status) {
        if (this.game.gameOver) {
          const winner = this.game.winner !== null ? this.game.winner + 1 : "unknown";
          const winnerName = this.mode === "bvb" ? `Bot ${winner}` : this.mode === "pvb" && this.game.winner === 1 ? "Bot" : `Player ${winner}`;
          status.textContent = `\u{1F389} ${winnerName} wins!`;
        } else if (this.isProcessing) {
          status.textContent = "\u{1F916} Bot is thinking...";
        } else {
          const currentName = this.mode === "bvb" ? `Bot ${this.game.currentPlayer + 1}` : this.mode === "pvb" && this.game.currentPlayer === 1 ? "Bot" : `Player ${this.game.currentPlayer + 1}`;
          if (this.game.diceConfig) {
            if (this.game.mustRollDice) {
              status.textContent = `${currentName}'s turn - \u{1F3B2} Roll the dice!`;
            } else {
              status.textContent = `${currentName}'s turn - ${this.game.movesRemaining} move(s) left`;
            }
          } else {
            status.textContent = `${currentName}'s turn`;
          }
        }
      }
      if (diceResult && this.game.diceConfig) {
        if (this.game.diceResult !== null && !this.game.mustRollDice) {
          diceResult.innerHTML = `
                            <div style="margin-top: 10px; padding: 8px; background: white; border-radius: 6px; font-weight: bold; color: #333;">
                                Result: ${this.game.diceResult}<br>
                                <span style="font-size: 12px; color: #666;">Moves left: ${this.game.movesRemaining}</span>
                            </div>
                        `;
        } else {
          diceResult.innerHTML = "";
        }
      }
      if (throwButton && this.game.diceConfig) {
        const shouldDisable = this.isProcessing || this.game.gameOver || !this.game.mustRollDice || this.mode === "pvb" && this.game.currentPlayer === 1 || this.mode === "bvb";
        throwButton.disabled = shouldDisable;
      }
      if (botBtn) {
        botBtn.disabled = this.isProcessing || this.game.gameOver || this.mode !== "pvb" || this.game.currentPlayer !== 1;
      }
    }
  };

  // packages/cli/out/scripts/app.js
  var cfg = globalThis.__GAME_CONFIG;
  if (!cfg) {
    console.error("Missing window.__GAME_CONFIG");
  } else {
    let throwDice = function() {
      const diceElement = document.querySelector(".dice");
      const resultElement = document.querySelector(".dice-result");
      const button = document.querySelector(".throw-button");
      if (!diceElement || !resultElement || !button)
        return;
      if (isRolling)
        return;
      if (!game.mustRollDice || game.gameOver) {
        console.log("Cannot roll dice right now");
        return;
      }
      isRolling = true;
      button.disabled = true;
      resultElement.textContent = "";
      diceElement.textContent = "\u{1F3B2}";
      diceElement.classList.add("rolling");
      setTimeout(() => {
        const result = game.rollDice();
        if (result !== null) {
          diceElement.classList.remove("rolling");
          diceElement.textContent = result.toString();
          resultElement.innerHTML = `
          <div style="margin-top: 10px; padding: 8px; background: white; border-radius: 6px; font-weight: bold; color: #333;">
            Result: ${result}<br>
            <span style="font-size: 12px; color: #666;">You have ${result} move(s)</span>
          </div>
        `;
        }
        isRolling = false;
        ui.render();
        ui.checkBotTurn();
      }, 600);
    };
    throwDice2 = throwDice;
    const diceConfig = cfg.dice || null;
    const game = new Game(cfg.boardSize, cfg.direction, cfg.pieces, cfg.firstPlayer, cfg.mandatoryCapture, diceConfig);
    const ui = new UI(game);
    let isRolling = false;
    const throwButton = document.querySelector(".throw-button");
    if (throwButton) {
      throwButton.addEventListener("click", throwDice);
    }
  }
  var throwDice2;
})();

</script>
</body>
</html>